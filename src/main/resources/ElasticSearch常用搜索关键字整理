常用的简单命令
1.查看索引结构
GET /index/_mapping

2.查看健康状态
GET /_cat/health?v

4.match
使用场景:一个精确值的字段上使用它， 例如数字、日期、布尔或者一个not_analyzed字符串字段
{
  "query": {
    "match": {
      "content": {
        "query": "我的宝马多少马力"
      }
    }
  }
}
5.match_phrase
精确匹配所有同时包含"宝马 多少 马力"的文档
{
  "query": {
    "match_phrase": {
      "content": {
        "query": "我的宝马多少马力"
      }
    }
  }
}
6.slop
完全匹配可能比较严，我们会希望有个可调节因子，少匹配一个也满足，那就需要使用到slop
{
  "query": {
    "match_phrase": {
      "content": {
        "query": "我的宝马多少马力",
        "slop": 1
      }
    }
  }
}
7.multi_match
如果我们希望两个字段进行匹配，其中一个字段有这个文档就满足的话，使用multi_match
{
  "query": {
    "multi_match": {
      "query": "我的宝马多少马力",
      "fields": [
        "title","content"
      ]
    }
  }
}
7.multi_match
如果我们希望匹配所有字段，其中一个字段有这个文档就满足的话，使用multi_match
{
  "query": {
    "multi_match": {
      "query": "我的宝马多少马力",
      "fields": ["_all"]
    }
  }
}

8.best_fields
我们希望完全匹配的文档占的评分比较高，则需要使用best_fields
{"query":{"multi_match":{"query":"我的宝马发动机多少","type":"best_fields","fields":["tag","content"],"tie_breaker":0.3}}}
9.most_fields
我们希望越多字段匹配的文档评分越高，就要使用most_fields
{"query":{"multi_match":{"query":"我的宝马发动机多少","type":"most_fields","fields":["tag","content"]}}}
10.cross_fields
我们会希望这个词条的分词词汇是分配到不同字段中
{
  "query": {
    "multi_match": {
      "query": "我的宝马发动机多少",
      "type": "cross_fields",
      "fields": [
        "tag",
        "content"
      ]
    }
  }
}
11.term
使用场景:精确值匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串
term是代表完全匹配，即不进行分词器分析，文档中必须包含整个搜索的词汇,区别于match
{"query":{"term":{"content":"汽车保养"}}}

12.terms
它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件
{"terms":{"tag":["search","full_text","nosql"]}}

13.match_all
查询简单的匹配所有文档
{"query":{"match_all":{}}}

14.range
指定区间的数字或者时间
{"range":{"age":{"gte":20,"lt":30}}}
gt 大于
gte 大于等于
lt 小于
lte 小于等于

15.exists查询和missing查询
exists 查询和 missing 查询被用于查找那些指定字段中有值 (exists) 或无值 (missing) 的文档。
这与SQL中的 IS_NULL (missing) 和 NOT IS_NULL (exists) 在本质上具有共性
{"exists":{"field":"title"}}
这些查询经常用于某个字段有值的情况和某个字段缺值的情况。

16.bool
bool可以连接组和一下几个参数条件：
- must:文档必须匹配这些条件才可以被筛选出来。
- must_not:文档必须不匹配这些条件才可以被筛选出来。
- should:如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响。它们主要用于修正每个文档的相关性得分。
- filter:必须 匹配，但它以不评分、过滤模式来进行。这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。

注意:精确值的查询,将使用filter代替query,因为filter将会被缓存

17.highlight
highlight可以对字段进行高亮显示
GET /.kibana/_search
{
  "query": {
    "match": {
      "space.name": "Default"
    }
  },
  "from": 0,
  "size": 20,
  "highlight": {
    "fields": {
      "space.name": {}
    }
  }
}
在实际中需要将返回结果中的<em>标签进行替换,达到高亮的效果

18.analyzer
分词qi


